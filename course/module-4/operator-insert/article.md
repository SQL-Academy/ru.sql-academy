# Добавление данных, оператор INSERT

Для добавления новых записей в таблицу предназначен оператор `INSERT`. Рассмотрим его общую структуру.

## Общая структура запроса с оператором INSERT

```sql
INSERT INTO имя_таблицы [(поле_таблицы, ...)]
VALUES (значение_поля_таблицы, ...)
| SELECT поле_таблицы, ... FROM имя_таблицы ...
```

Значения можно вставлять перечислением с помощью слова `VALUES`, перечислив их в круглых скобках через запятую или c помощью оператора `SELECT`.

Таким образом, добавить новые записи можно следующими способами:

-   Используя синтаксис `INSERT INTO ... SELECT`

    ```sql-executable-Family-targetTable:Goods
    INSERT INTO Goods (good_id, good_name, type)
    SELECT 20, 'Table', 2;
    ```

-   Используя синтаксис `INSERT INTO ... VALUES (...)`

    ```sql-executable-Family-targetTable:Goods
    INSERT INTO Goods (good_id, good_name, type)
    VALUES (20, 'Table', 2);
    ```

Каждый из этих запросов даст одинаковый результат:

| good_id | good_name          | type |
| ------- | ------------------ | ---- |
| 1       | apartment fee      | 1    |
| 2       | phone fee          | 1    |
| 3       | bread              | 2    |
| 4       | milk               | 2    |
| 5       | red caviar         | 3    |
| 6       | cinema             | 4    |
| 7       | black caviar       | 3    |
| 8       | cough tablets      | 5    |
| 9       | potato             | 2    |
| 10      | pineapples         | 3    |
| 11      | television         | 8    |
| 12      | vacuum cleaner     | 8    |
| 13      | jacket             | 7    |
| 14      | fur coat           | 7    |
| 15      | music school fee   | 6    |
| 16      | english school fee | 6    |
| 20      | Table              | 2    |

## Первичный ключ при добавлении новой записи

Следует помнить, что первичный ключ таблицы является уникальным значением и добавление уже существующего значения приведёт к ошибке.

При добавлении новой записи с уникальными индексами выбор такого уникального значения может оказаться непростой задачей.
Решением может быть дополнительный запрос, направленный на выявление максимального значения первичного ключа для генерации нового уникального значения.

```sql
INSERT INTO Goods SELECT COUNT(*) + 1, 'Table', 2 FROM Goods;
```

## MySQL

В MySQL введён механизм его автоматической генерации. Для этого достаточно снабдить первичный ключ `good_id` атрибутом `AUTO_INCREMENT`.
Тогда при создании новой записи в качестве значения `good_id` достаточно передать `NULL` или `0` — поле автоматически получит значение, большее предыдущего на единицу.

```sql
CREATE TABLE Goods (
	good_id INT NOT NULL AUTO_INCREMENT
	...
);
```

```sql
INSERT INTO Goods VALUES (NULL, 'Table', 2);
```

## PostgreSQL

В PostgreSQL есть схожий механизм для автоматической генерации уникального идентификатора.
Для этого он имеет типы `SMALLSERIAL`, `SERIAL`, `BIGSERIAL`, которые не являются настоящими типами, а скорее просто удобством записи столбцов с уникальным идентификатором.
Столбец с одним из вышеперечисленных типов будет являться целочисленным и автоматически увеличиваться при добавлении новой записи.

```sql
CREATE TABLE Goods (
	good_id SERIAL
	...
);
```

```sql
INSERT INTO Goods (good_name, type) VALUES ('Table', 2);
```
